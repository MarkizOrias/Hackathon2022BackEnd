// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract ProofOfProp is Ownable {
    mapping(address => uint256) public addressToAmountFunded;
    address payable[] public clients; // An array with clients' addresses (funders)
    uint256 public usdMinimumFee; // A fee variable
    uint256 public usdEntryFee; // variable
    address payable contract_owner; // Our owner wallet address
    AggregatorV3Interface internal ethUsdPriceFeed;

    modifier onlyOwner() override {
        require(
            msg.sender == contract_owner,
            "Your account address is not an owner of the contract"
        );
        //run this than...
        _;
        //...all the rest
    }

    function showOwner() public view returns (address) {
        return contract_owner;
    }

    constructor(address _priceFeedAddress) {
        ethUsdPriceFeed = AggregatorV3Interface(_priceFeedAddress); // Assignment of price feed variable
        usdMinimumFee = 50 * (10**18); // Assignment of minimum fee value
    }

    function record() public payable {
        require(
            msg.value >= getMinimumFee(),
            "Not enough ETH! Entry below minimum fee in USD"
        ); // Check if a payment is equal or above minimum fee
        clients.push(payable(msg.sender)); // Pushing address to the clients array
    }

    function getMinimumFee() public view returns (uint256) {
        (, int256 price, , , ) = ethUsdPriceFeed.latestRoundData(); // Takes this from AggregatorV3 latestRoundData
        uint256 adjustedPrice = uint256(price) * 10**10; // adjustedPrice has to be expressed with 18 decimals. From Chainlink pricefeed, we know ETH/USD has 8 decimals, so we need to multiply by 10^10
        uint256 costToEnter = (usdEntryFee * 10**18) / adjustedPrice; // We cannot return decimals, hence we need to express 50$ with 50 * 10*18 / 2000 (adjusted price of ETH)
        return costToEnter; // for testing
    }

    // mapping(address => string) public addressToName;

    struct UserParameters {
        string certificate_ref; // generated by our system
        string registration_date; // read data from current data function of python
        string title; // user input
        address user_address; // This should be read from address, which paid fee
        string user_name; // user input
        string additional_owner; // user input
        string user_file_hash; // hash generated and based on file chosen by user
    }

    UserParameters[] public users;

    function addUser(
        string memory _certificate,
        string memory _date,
        string memory _title,
        address _address,
        string memory _name,
        string memory _additional,
        string memory _hash
    ) public {
        users.push(
            UserParameters(
                _certificate,
                _date,
                _title,
                _address,
                _name,
                _additional,
                _hash
            )
        );
    }

    function withdraw() public payable onlyOwner {
        require(msg.sender == contract_owner);
        payable(msg.sender).transfer(address(this).balance);
        //this is a contract we are in, address is the address of a contract.
        //balance is the current balance on a contract (a method)
        //msg.sender - whoever calls this function
        //transfer the balance

        for (
            uint256 clientIndex = 0;
            clientIndex < clients.length;
            clientIndex++
        ) {
            address client = clients[clientIndex];
            addressToAmountFunded[client] = 0;
        }
        //loop through all clients, read their address from an array and nullify their balances
        clients = new address payable[](0); //???
    }
}
